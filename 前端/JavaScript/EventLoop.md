### JavaScript事件循环机制
```
 javascript是单线程非阻塞的脚本语言。
 单线程:只有一个线程来处理所有任务。
 
```
###执行栈
当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的同步任务按照执行顺序排队到一个地方，这个地方叫做执行栈。

###事件队列
当我们发出一个ajax请求，他并不会立刻返回结果，为了防止浏览器出现假死或者空白，主线程会把这个异步任务挂起(pending)，继续执行执行栈中的其他任务，等异步任务返回结果后，js会将这个异步任务按照执行顺序，加入到与执行栈不同的另一个队列，也就是事件队列。

### 浏览器中的Event Loop

![avatar](https://pic4.zhimg.com/80/v2-f8f6d06b689a6230f30e28b64ad5b583_hd.jpg)

主线程运行的时候会生成堆（heap）和栈（stack）；
js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中；
当程序调用外部的API时，比如ajax、setTimeout等，会将此类异步任务挂起，继续执行执行栈中的任务，等异步任务返回结果后，再按照执行顺序排列到事件队列中；
主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中。
主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个过程是循环往复的... ...，这个过程被称为“Event Loop 事件循环”。
大概知道了 Event Loop 执行时是一个什么样的过程，现在我们通过代码来感受一下。
```
console.log(1);

 setTimeout(() => {
   console.log(2);
   setTimeout(() => {
     console.log(3);
     setTimeout(() => {
       console.log(4);
     }, 0) ;
   }, 0) ;
 }, 0);

 setTimeout(() => {
   console.log(5);
   setTimeout(() => {
     console.log(6);
   }, 0);
 }, 0);

 console.log('ok');
```